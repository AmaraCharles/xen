"use strict";(self.webpackChunktradingview=self.webpackChunktradingview||[]).push([[44572],{220732:(e,t,n)=>{n.d(t,{ChannelMultiplexer:()=>s});class s{constructor(){this._handlers={},this._specialHandlers={}}on(e,t){const n=this._isSpecialChannel(e)?this._specialHandlers:this._handlers;n[e]||(n[e]=[]),n[e].push(t)}off(e,t){const n=this._isSpecialChannel(e)?this._specialHandlers:this._handlers;if(!(e in n))return;if(void 0===t)return void delete n[e];const s=n[e].indexOf(t);s>=0&&n[e].splice(s,1)}emit(e,t,n,s){this._handlers[n]&&this._handlers[n].forEach((o=>{o(e,t,n,s)}));for(const o of Object.keys(this._specialHandlers)){const i="^"+o.replace(/\*/g,".*?")+"$";new RegExp(i).test(n)&&this._specialHandlers[o].forEach((o=>{o(e,t,n,s)}))}}_isSpecialChannel(e){return/\*/.test(e)}}},700469:(e,t,n)=>{n.d(t,{MultiplexerState:()=>c});var s=n(942634),o=n(79342),i=n(955273),r=n(226722),a=n(995773);class c{constructor(){this._id=(0,o.guid)(),this._state={[this._id]:{}},this._xEventPrefix="multiplexer-state-",this._xEventCreateTab=this._xEventPrefix+"create-new-tab",this._xEventShareState=this._xEventPrefix+"share-state",this._lockName="tab_destruction",this._stateChangeDelegate=new s.Delegate,this._createdLocks={},this._lockEnabled=(0,a.webLockEnabled)(),this._lockPromise=(0,i.createDeferredPromise)(),this._onTabCreateCb=null,this._onTabCreate=e=>{this._onTabCreateCb&&this._onTabCreateCb();const t=JSON.parse(e);this._state[t]={},this._shareState(),this._requestTabRemoveLock(t)},this._shareState=()=>{const e=JSON.stringify([this._id,this._state[this._id]]);r.TVXWindowEvents.emit(this._xEventShareState,e)},this._requestTabRemoveLock=e=>{!this._createdLocks[e]&&this._lockEnabled&&(this._createdLocks[e]=1,navigator.locks.request(`${this._lockName}_${e}`,(async()=>{const t=this._state[e]||{};this._compareTabState(e,{},t,"add"),this._compareTabState(e,t,{},"remove"),delete this._state[e],delete this._createdLocks[e]})))},this._onShareStateFromOther=e=>{const[t,n]=JSON.parse(e),s=this._state[t]||{};this._compareTabState(t,n,s,"add"),this._compareTabState(t,s,n,"remove"),this._state[t]=n,this._requestTabRemoveLock(t)},this._removeChannel=(e,t)=>{delete this._state[this._id][e][t],this._isListenByAnotherTab(e,t)||this._stateChangeDelegate.fire("remove",e,t);0===Object.keys(this._state[this._id][e]).length&&delete this._state[this._id][e]},r.TVXWindowEvents.on(this._xEventCreateTab,this._onTabCreate),r.TVXWindowEvents.on(this._xEventShareState,this._onShareStateFromOther),this._lockEnabled&&navigator.locks.request(`${this._lockName}_${this._id}`,(async()=>(r.TVXWindowEvents.emit(this._xEventCreateTab,JSON.stringify(this._id)),window.addEventListener("beforeunload",(()=>this._lockPromise.resolve())),this._lockPromise.promise)))}addChannel(e,t){this._isNotEmpty(e,t)?this._state[this._id][e][t]++:(this._state[this._id][e]||(this._state[this._id][e]={}),this._state[this._id][e][t]=1),this._isListenByAnotherTab(e,t)||this._stateChangeDelegate.fire("add",e,t),this._shareState()}removeChannel(e,t){
this._isExist(e,t)&&(this._state[this._id][e][t]--,this._isNotEmpty(e,t)||this._removeChannel(e,t),this._shareState())}collectPushStreamChannels(e){const t=new Set;return Object.keys(this._state).forEach((n=>{const s=this._state[n][e];this._state[n][e]&&Object.keys(s).forEach((e=>t.add(e)))})),Array.from(t)}onStateChange(e){this._stateChangeDelegate.subscribe(null,e)}offStateChange(e){this._stateChangeDelegate.unsubscribe(null,e)}onTabCreate(e){this._onTabCreateCb=e}_isExist(e,t,n=this._id){return void 0!==this._state[n]&&void 0!==this._state[n][e]&&void 0!==this._state[n][e][t]}_isNotEmpty(e,t,n=this._id){return this._isExist(e,t,n)&&this._state[n][e][t]>0}_compareTabState(e,t,n,s){Object.keys(t).forEach((o=>{Object.keys(t[o]).forEach((t=>{this._isListenByAnotherTab(o,t,e)||n[o]&&n[o][t]||this._stateChangeDelegate.fire(s,o,t)}))}))}_isListenByAnotherTab(e,t,n=this._id){return Object.keys(this._state).some((s=>s!==n&&this._isNotEmpty(e,t,s)))}}},358956:(e,t,n)=>{n.d(t,{PushStream:()=>m,TransportType:()=>g,loggerSubsystemId:()=>d});var s=n(650151),o=n(5553),i=n(338619),r=n(454576),a=n(78770);const c=(0,i.getLogger)("PersistentWebsocketTransport");class h extends a.PersistentTransport{constructor(e,t){super(e,c,t)}sendMessage(e){this._connectionStatus.value()===r.ConnectionStatus.Open?this._socket?this._socket.send(e):c.logError("Something went wrong - code 0x3"):c.logWarn("Attempt to send message but connection is not opened")}_createNativeTransport(e){const t=new WebSocket(e);return t.binaryType="arraybuffer",t.addEventListener("error",this._socketErrorHandler),t.addEventListener("close",this._socketCloseHandler),t.addEventListener("open",this._socketOpenHandler),t.addEventListener("message",this._socketMessageHandler),t}_disconnectTransport(){if(null===this._socket)return;this._socket.removeEventListener("error",this._socketErrorHandler),this._socket.removeEventListener("close",this._socketCloseHandler),this._socket.removeEventListener("open",this._socketOpenHandler),this._socket.removeEventListener("message",this._socketMessageHandler),this._removeOnOfflineListener();const e=this._socket;this._socket=null,this._connectionStatus.setValue(r.ConnectionStatus.Closed),e.readyState!==WebSocket.CLOSED&&e.close()}}var l=n(175203);class _{constructor(e){this._queue=[],this._isWorking=!1,this._onResolve=()=>{this._queue.length>0&&this._createPromise(this._queue[0])},this._logger=e}enqueue(e){this._logger.logNormal(`Adding channel in stack. Queue size: ${this._queue.length}`),this._isWorking||this._createPromise(e),this._queue.push(e)}_createPromise(e){this._isWorking=!0,this._wrap(e).then(this._onResolve)}_wrap(e){return new Promise((t=>{e().catch((e=>this._logger.logNormal(`Error when trying handling channel: ${e.message}`))).finally((()=>{this._isWorking=!1,this._queue.shift(),t()}))}))}}const d="PushStream",u=(0,i.getLogger)(d);var g;!function(e){e[e.EventSource=0]="EventSource",e[e.WebSocket=1]="WebSocket"}(g||(g={}));class m{constructor(e,t){this._channels=[],this._queue=new _(u),
this._transport=t.transportType===g.EventSource?new o.PersistentEventSourceTransport(this._onPushStreamMessage.bind(this)):new h(this._onPushStreamMessage.bind(this),this._onPushStreamClose.bind(this)),this._settings=t,this._messageHandler=e}addChannel(e){this._queue.enqueue((()=>this._addChannel(e)))}removeChannel(e){this._queue.enqueue((()=>this._removeChannel(e)))}getChannels(){return this._channels}hasChannel(e){return-1!==this._channels.indexOf(e)}connectionStatus(){return this._transport.connectionStatus()}reconnectEvent(){return this._transport.successReconnectReachedEvent()}connect(){(0,s.assert)(0!==this._channels.length,"There is no channels"),this._transport.connect()}disconnect(){this._transport.disconnect()}getLogs(e){return(0,i.getRawLogHistory)(e,d)}async _addChannel(e){(0,s.assert)(!this.hasChannel(e),`Channel with name ${e} has already been subscribed`),u.logNormal(`Adding channel ${e}`),this._channels.push(e);const{maxSize:t}=this._settings;return void 0!==t&&this._channels.length>t&&(this._channels=this._channels.slice(this._channels.length-t)),this._transport.setUrl(this._generateUrl())}async _removeChannel(e){const t=this._channels.indexOf(e);return(0,s.assert)(-1!==t,`There is no channel with name ${e}`),u.logNormal(`Removing channel ${e}`),this._channels.splice(t,1),this._transport.setUrl(this._generateUrl())}_onPushStreamMessage(e){if("string"!=typeof e)throw new Error("Wrong message type, expected string");const t=JSON.parse(e),n=t.id,s=t.channel;-2===n?u.logWarn("Received unexpected message: about removed the channel"):n>0&&(u.logDebug(`Received message: id="${n}" channel="${s}"`),this._messageHandler(t.text,n,s))}_onPushStreamClose(e){1005===e.code&&l.telemetry.sendChartReport("websocket_code_1005")}_generateUrl(){const e=this._channels.join("/");return u.logNormal(`Generate pushstream url - ${e}`),`${this._settings.url}/${this._settings.urlPath}/${e}`}}},995773:(e,t,n)=>{n.d(t,{webLockEnabled:()=>o});var s=n(167175);function o(){return!s.isIOS&&!s.isIPad&&void 0!==navigator.locks}},5553:(e,t,n)=>{n.d(t,{PersistentEventSourceTransport:()=>r});var s=n(454576),o=n(78770);const i=(0,n(338619).getLogger)("PersistentWebsocketTransport");class r extends o.PersistentTransport{constructor(e){super(e,i),this._specializedErrorHandlerBound=this._specializedErrorHandler.bind(this)}_createNativeTransport(e){const t=new EventSource(e,{withCredentials:!0});return t.addEventListener("error",this._specializedErrorHandlerBound),t.addEventListener("open",this._socketOpenHandler),t.addEventListener("message",this._socketMessageHandler),t}_disconnectTransport(){if(null===this._socket)return;this._socket.removeEventListener("error",this._specializedErrorHandlerBound),this._socket.removeEventListener("open",this._socketOpenHandler),this._socket.removeEventListener("message",this._socketMessageHandler),this._removeOnOfflineListener();const e=this._socket;this._socket=null,this._connectionStatus.setValue(s.ConnectionStatus.Closed),e.readyState!==WebSocket.CLOSED&&e.close()}_specializedErrorHandler(e){
e.eventPhase===EventSource.CLOSED?this._socketCloseHandler(e):this._socketErrorHandler()}}},78770:(e,t,n)=>{n.d(t,{PersistentTransport:()=>c});var s=n(454576),o=n(878),i=n(375397),r=n(942634),a=n(622864);class c{constructor(e,t,n){this._url="",this._socket=null,this._reconnectCount=0,this._onlineCancellationToken=null,this._connectionStatus=new i.WatchedValue(s.ConnectionStatus.Closed),this._socketCloseHandler=this._onCloseCallback.bind(this),this._socketErrorHandler=this._onErrorCallback.bind(this),this._socketOpenHandler=this._onOpenCallback.bind(this),this._socketMessageHandler=this._onMessageCallback.bind(this),this._maxReconnectReachedEventDelegate=new r.Delegate,this._successReconnectReachedEventDelegate=new r.Delegate,this._shouldReconnect=!0,this._maxReconnectCount=null,this._reconnectTimeoutId=0,this._connectAbortController=null,this._tryReconnect=()=>{if(this._disconnect(),this._shouldReconnect){const e=this._getReconnectTimeout();this._logger.logNormal(`Sleeping some time before reconnect ${e}ms`),this._reconnectTimeoutId=setTimeout(this._tryReconnectImpl.bind(this),e)}else this._logger.logNormal("Skip reconnecting because of shouldReconnect state")},this._onOfflineHandler=()=>{this._removeOnOfflineListener(),this._logger.logInfo("Network status changed to offline - trying to reconnect"),this._tryReconnect()},this._logger=t,this._messageHandler=e,this._closeHandler=n,window.addEventListener("unload",(()=>{t.logNormal("Unload event comes - disconnecting without reconnect after that..."),this._shouldReconnect=!1,this._disconnect()}),!1)}setUrl(e){if(this._url===e)return Promise.resolve();const t=this._connectionStatus.value()!==s.ConnectionStatus.Closed;return t&&this._disconnect(),this._url=e,t?this.connect():Promise.resolve()}url(){return this._url}connect(){return this._connectImpl()}setMaxReconnectCount(e){this._maxReconnectCount=e}connectionStatus(){return this._connectionStatus.readonly()}disconnect(){this._shouldReconnect=!1,this._disconnect()}maxReconnectReachedEvent(){return this._maxReconnectReachedEventDelegate}successReconnectReachedEvent(){return this._successReconnectReachedEventDelegate}async _prepareParamsForConnection(e){}_disconnect(){var e;null===(e=this._connectAbortController)||void 0===e||e.abort(),this._connectAbortController=null,clearTimeout(this._reconnectTimeoutId),this._reconnectTimeoutId=0,this._connectionStatus.value()!==s.ConnectionStatus.Closed?this._socket?(this._logger.logNormal(`Closing connection to: ${this._socket.url}, currentStatus: ${s.ConnectionStatus[this._connectionStatus.value()]}`),this._disconnectTransport()):this._logger.logNormal("Disconnecting without socket - probably within preparing, it should be already scheduled for aborting"):this._logger.logNormal("Attempt to close connection but it is closed already")}_onErrorCallback(){this._logger.logInfo("Connection is closed by error"),this._tryReconnect()}_onCloseCallback(e){var t;this._logger.logInfo(`Connection is closed - code=${e.code} msg=${e.reason}`),
null===(t=this._closeHandler)||void 0===t||t.call(this,e),this._tryReconnect()}_tryReconnectImpl(){return null!==this._maxReconnectCount&&this._reconnectCount===this._maxReconnectCount?(this._logger.logWarn("Maximum attempts to reconnect to websocket reached"),void this._maxReconnectReachedEventDelegate.fire()):(this._reconnectCount+=1,this._logger.logInfo(`Reconnecting count: ${this._reconnectCount}`),navigator.onLine?(this._logger.logInfo("Network status: online - trying to connect"),void this.connect()):(this._logger.logInfo("Network status: offline - wait until online"),void(this._onlineCancellationToken=(0,o.callWhenOnline)((()=>{this._logger.logInfo("Network status changed to online - trying to connect"),this.connect()})))))}_onOpenCallback(){this._logger.logNormal("Connection opened"),this._reconnectCount>0&&this._successReconnectReachedEventDelegate.fire(),this._reconnectCount=0,this._connectionStatus.setValue(s.ConnectionStatus.Open)}_onMessageCallback(e){this._messageHandler(e.data)}_getReconnectTimeout(){return this._reconnectCount<5?300:5e3}_setOnOfflineListener(){window.addEventListener("offline",this._onOfflineHandler)}_removeOnOfflineListener(){window.removeEventListener("offline",this._onOfflineHandler)}async _connectImpl(){if(this._connectionStatus.value()!==s.ConnectionStatus.Closed)return void this._logger.logNormal("Attempt to open connection but it is not closed");this._socket&&(this._logger.logError("Something went wrong - code 0x2"),this.disconnect()),this._onlineCancellationToken&&(this._onlineCancellationToken(),this._onlineCancellationToken=null),this._logger.logNormal(`Connecting to ${this._url}`),this._shouldReconnect=!0,this._connectAbortController=new AbortController;const e=this._connectAbortController.signal;try{if(this._connectionStatus.setValue(s.ConnectionStatus.Connecting),await this._prepareParamsForConnection(e),e.aborted)throw(0,a.createAbortError)();this._socket=this._createNativeTransport(this._url),this._setOnOfflineListener()}catch(e){this._connectionStatus.setValue(s.ConnectionStatus.Closed),(0,a.skipAbortError)(e)}finally{this._connectAbortController=null}}}},878:(e,t,n)=>{function s(e){let t=e;const n=()=>{window.removeEventListener("online",n),t&&t()};return window.addEventListener("online",n),()=>{t=null}}n.d(t,{callWhenOnline:()=>s})}}]);